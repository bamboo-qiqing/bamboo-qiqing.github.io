import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as i,a as n,d as a,b as o,e as p,r as c}from"./app.b354d91e.js";const l="/assets/image-20200623134112047.0f7447b3.png",r="/assets/image-20200623135211410.db302ec5.png",d="/assets/image-20200623140440544.a304b34a.png",u="/assets/image-20200623141205312.bbdb2bd8.png",h="/assets/image-20200623141825523.50b06d37.png",g="/assets/image-20200623143852813.b59046e1.png",b="/assets/image-20200623145055359.88c1cecc.png",k="/assets/image-20200623152555013.a6675c59.png",m={},_=p('<h1 id="相关概念介绍" tabindex="-1"><a class="header-anchor" href="#相关概念介绍" aria-hidden="true">#</a> 相关概念介绍</h1><p>RabbitMQ 整体上是一个 <strong>生产者与消费者模型</strong>，主要负责 <strong>接收、存储和转发消息</strong>。</p><p><img src="'+l+'" alt="image-20200623134112047"></p><h2 id="生产者和消费者" tabindex="-1"><a class="header-anchor" href="#生产者和消费者" aria-hidden="true">#</a> 生产者和消费者</h2><h3 id="生产者" tabindex="-1"><a class="header-anchor" href="#生产者" aria-hidden="true">#</a> 生产者</h3><p>Producer：生产者，投递消息的一方</p><p>生产者创建消息，发布到 RabbitMQ 中。</p><p>消息一般可以包含 2 个部分：</p><ul><li><p>消息体（payload）</p><p>你的业务数据，比如一个 JSON 字符串</p></li><li><p>标签（label）：用来描述这条消息</p><p>比如：一个交换器的名称和一个路由键。RabbitMQ 会根据标签把消息发送给感兴趣的消费者（Consumer）</p></li></ul><h3 id="消费者" tabindex="-1"><a class="header-anchor" href="#消费者" aria-hidden="true">#</a> 消费者</h3><p>Consumer：消费者，接收消息的一方</p><p>消费者链接到 RabbitMQ，并 <strong>订阅到队列</strong> 上。当消费者消费一条消息时，只是消费消息的 <strong>消息体（payload）</strong>，路由过程中，<strong>消息的标签会丢弃</strong>，<strong>存入到队列中的消息只有消息体</strong>。</p><p>消费者不知道生产者是谁。</p><h3 id="broker" tabindex="-1"><a class="header-anchor" href="#broker" aria-hidden="true">#</a> Broker</h3><p>Broker：消息中间件的服务节点。</p><p>对于 RabbitMQ 来说，一个 Broker 可以简单看成一个 RabbitMQ 服务节点，或则 RabbitMQ 服务实例。</p><p>下图展示了：生产者将消息存入 Broker，以及消费者从 Broker 中消费数据的整个流程</p><p><img src="'+r+'" alt="image-20200623135211410"></p><ul><li><p>生产者将消息发送到 Broker 中</p><p>发送：对应的 AMQP 协议命令为 <code>Basic.Publish</code></p></li><li><p>消费者订阅并接收消息</p><p>订阅并接收：对应的 AMQP 协议命令为 <code>Basic.Consume</code> 或 <code>Basic.Get</code></p></li></ul><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><p>Queue：队列 ，是 RabbitMQ 的内部对象，用于存储消息。</p><p>RabbitMQ 中消息都 <strong>只能存储在队列中</strong>，kafka 将消息存储在 topic 这个逻辑层面中，而相对应的队列逻辑知识 topic 实际存储文件中的位置偏移标识。</p><p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被 <strong>平均分摊</strong>（Round-Robin 轮询）给多个消费者进行处理。</p><p><img src="'+d+'" alt="image-20200623140440544"></p><p>RabbitMQ <strong>不支持队列层面的广播消息</strong>，如果需要广播消费，需要进行二次开发，麻烦，不推荐。</p><h2 id="交换器、路由键、绑定" tabindex="-1"><a class="header-anchor" href="#交换器、路由键、绑定" aria-hidden="true">#</a> 交换器、路由键、绑定</h2><h3 id="exchange-交换器" tabindex="-1"><a class="header-anchor" href="#exchange-交换器" aria-hidden="true">#</a> Exchange 交换器</h3><p>在图 2-4 中，消息并不是直接到队列中的，而是消息先到 Exchange（交换器，通常用大写的 X 表示），<strong>由交换器将消息路由到一个或多个队列中</strong>。如果路由不到，或许会返回给生产者，或许会直接丢弃。</p><p>示意图如下</p><p><img src="'+u+'" alt="image-20200623141205312"></p><p>RabbitMQ 中的交换器有 4 种类型，不同的类型有不同的策略，后续详细讲解。</p><h3 id="routingkey-路由键" tabindex="-1"><a class="header-anchor" href="#routingkey-路由键" aria-hidden="true">#</a> RoutingKey 路由键</h3><p>生产者将消息发给交换器时，一般会指定一个 RoutingKey，用来指定这个消息的路由规则。</p><p>RoutingKey 需要与<strong>交换器类型</strong>和 <strong>绑定键（BindingKey）</strong> 联合使用才能最终生效</p><h3 id="binding-绑定" tabindex="-1"><a class="header-anchor" href="#binding-绑定" aria-hidden="true">#</a> Binding 绑定</h3><p>通过 <strong>绑定</strong> 将 <strong>交换器与队列关联</strong> 起来，绑定时一般会指定一个 <strong>绑定键（BindingKey）</strong>，这样 RabbitMQ 就知道如何正确将消息路由到队列了，示意图如下：</p><p><img src="'+h+`" alt="image-20200623141825523"></p><p>生产者将消息发送给交换器时，需要一个 RoutingKey，<strong>当 BindingKey 和 RoutingKey 匹配时</strong>，消息被路由到对应的队列中。</p><p>绑定多个队列到同一个交换器时，BindingKey 允许相同。BindingKey 只能在 <strong>指定的交换器类型下生效</strong>，比如 fanout 类型的交换器就不生效，它将消息路由到所有绑定到该交换器的队列中。</p><p>其实你已经发现了：在某些情况下，RoutingKey 与 BindingKey 可以看成是同一个东西，因为他们要匹配才能路由。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 创建一个 type=direct 持久化、非自动删除的交换器</span>
channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span><span class="token constant">EXCHANGE_NAME</span><span class="token punctuation">,</span> <span class="token string">&quot;direct&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个：持久化、非排他的、非自动删除的队列</span>
channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token constant">QUEUE_NAME</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将交换器与队列通过 路由键 绑定</span>
channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token constant">QUEUE_NAME</span><span class="token punctuation">,</span> <span class="token constant">EXCHANGE_NAME</span><span class="token punctuation">,</span> <span class="token constant">ROUTING_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token constant">EXCHANGE_NAME</span><span class="token punctuation">,</span>
                     <span class="token constant">ROUTING_KEY</span><span class="token punctuation">,</span>
                     <span class="token class-name">MessageProperties</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT_TEXT_PLAIN</span><span class="token punctuation">,</span>
                     message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上部分代码，声明了一个 direct 类型的交换交换器，将队列绑定到交换机使用的是 ROUTING_KEY，这里本应该使用 BindingKey， <code>channel.basicPublis</code> 中发送消息也使用了 ROUTING_KEY，这说明在 direct 类型的交换器中他们是同一个东西。</p><p>但是在 topic 交换器类型下，ROUTING_KEY 和 BindingKey 之间需要做模糊匹配，他们就不是相同的了；</p><p>为了避免混淆，可以如下理解：</p><ul><li><p>在使用绑定的时候，需要的是 BindingKey</p><p>对应的 API 是 <code>channel.exchangeBind</code> 、<code>channel.queueBind</code></p><p>对应的 AMQP 命令是 <code>Exchange.Bind</code> 、<code>Queue.Bind</code></p></li><li><p>在发送消息时，使用的是 ROUTING_KEY</p><p>对应的 API 是：<code>channel.basicPublish</code></p><p>对应的 AMQP 命令是：<code>Basic.Publish</code></p></li></ul><h2 id="交换器类型" tabindex="-1"><a class="header-anchor" href="#交换器类型" aria-hidden="true">#</a> 交换器类型</h2><p>RabbitMQ 常用的交换器类型有：</p><ul><li>fanout：相当于广播消息，广播到绑定到交换器的队列</li><li>direct：路由到 RoutingKey 与 BindingKey 相同的队列</li><li>topic</li><li>headers</li></ul><p>AMQP 协议里还有两种类型：System 和 自定义。这里只讲解以上 4 种类型。</p><h3 id="fanout" tabindex="-1"><a class="header-anchor" href="#fanout" aria-hidden="true">#</a> fanout</h3><p>把所有发送到该交换器的消息路由到所有与交换器绑定的队列中。<strong>相当于广播消息</strong></p><h3 id="direct" tabindex="-1"><a class="header-anchor" href="#direct" aria-hidden="true">#</a> direct</h3><p>把消息 <strong>路由到 BindingKey 和 RoutingKey 完全匹配的队列中</strong>。</p><p><img src="`+g+'" alt="image-20200623143852813"></p><p>Queue 2 绑定了 3 个 BindingKey，当消息指定的 RoutingKey 为 warming 时，两个队列都能收到，为 info 时，就只有 Queue 2 能收到。</p><h3 id="topic" tabindex="-1"><a class="header-anchor" href="#topic" aria-hidden="true">#</a> topic</h3><p>与 direct 类型的交换器相似，也是将消息路由到 RoutingKey 与 BindingKey 相匹配的队列中，但是这里的匹配规则不同，它约定：</p><ul><li><p>RoutingKey 为一个点号「<code>.</code>」分隔的字符串</p><p>被「<code>.</code>」 分隔开的每一段独立的字符串成为一个单词。如 <code>com.rabbitmq.client</code></p></li><li><p>BindingKey 和 RoutingKey 一样也是一个点号「<code>.</code>」分隔的字符串</p></li><li><p>BindingKey 中可以存在两种特殊字符串，用作模糊匹配</p><ul><li><p><code>#</code>：用于匹配一个单词</p></li><li><p><code>*</code>：用于匹配多规格的单词，可以是零个</p></li></ul></li></ul><p><img src="'+b+'" alt="image-20200623145055359"></p><p>对于以上设置绑定关系，如下的路由键路由方向为：</p><ul><li><code>com.rabbitmq.client</code>：同时路由到 Q1 和 Q2</li><li><code>com.hidden.client</code>：只路由到 Q2</li><li><code>com.hidden.demo</code>：只路由到 Q2，因为匹配了 ``com.hidden`</li><li><code>java.rabbitmq.demo</code>：只会路由到 Q1</li><li><code>java.util.concurrent</code>：没有匹配任何路由键，可能被丢弃或返回给生产者（需要设置 mandatory 参数）</li></ul><h3 id="headers" tabindex="-1"><a class="header-anchor" href="#headers" aria-hidden="true">#</a> headers</h3><p>headers 类型的交换器 <strong>不依赖于路由键的匹配规则来路由消息</strong>，根据发送的消息内容中的 <strong>headers 属性进行匹配</strong>。</p><p>在绑定队列和交换器时制定一组键值对，发送消息到交换器时，会获取该消息的 headers ，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，完全匹配则路由到该队列。</p><p>headers 类型的交换器性能会很差，不推荐使用。</p><h2 id="rabbitmq-的运转流程" tabindex="-1"><a class="header-anchor" href="#rabbitmq-的运转流程" aria-hidden="true">#</a> RabbitMQ 的运转流程</h2><p>回顾下整个消息队列的使用过程，在最初状态下，生产者发送消息时：</p><ol><li><p>连接到 RabbitMQ Broker，建立一个连接 Connection，开启一个信道 Channel</p></li><li><p>声明一个交换器，并设置相关属性</p><p>比如：交换器类型、是否持久化等</p></li><li><p>声明一个队列，并设置相关属性</p><p>比如：是否排他、是否持久化、是否自动删除等</p></li><li><p>通过路由键将交换器和队列绑定起来</p></li><li><p>发送消息到 Broker</p><p>其中包含：路由键、交换器等信息</p></li><li><p>相应交换器根据接收到的路由键查找匹配的队列</p></li><li><p>如果找到：则存入相应的队列中。</p></li><li><p>如果没有找到：则根据生产者配置的属性，选择丢弃还是回退给生产者</p></li><li><p>关闭信道和链接</p></li></ol><p>消费者接收消息的过程：</p><ol><li>链接到 RabbitMQ Broker，建立一个链接 Connection，开启一个信道 Channel</li><li>向 Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作</li><li>等待 Broker 回应并投递相依队列中的消息，消费者接收消息</li><li>消费者确认（ack）接收消息</li><li>RabbitMQ 从队列中删除相应以及被确认的消息</li><li>关闭信道和链接</li></ol><p><img src="'+k+'" alt="image-20200623152555013"></p><p>无论生产者与消费者都要与 Broker 建立连接，该链接就是一条 TCP 链接（Connection）。客户端可以创建一个 AMQP 信道（Channel），<strong>每个信道会被指派一个唯一的 ID</strong>。</p><p><strong>信道是建立在 Connection 之上的虚拟连接</strong>，RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。这个模式是类似 NIO（Non-blocking I/O）的做法，TCP 链接复用，减少性能开销，同时也便于管理。</p>',73),f={class:"custom-container tip"},B=n("p",{class:"custom-container-title"},"NIO",-1),R=n("p",null,"NIO 也称非阻塞 I/O，包含三大核心部分：Channel 信道、Buffer 缓冲区、Selector 选择器。",-1),y=n("p",null,"NIO 基于 Channel 和 Buffer 进行操作，数据总是从信道读取到缓冲区中，或则从缓冲区写入到信道中。",-1),v=n("p",null,"Selector 用于监听多个信道的事件（如：打开链接、数据到达等）。因此，单线程可以监听多个数据的信道。",-1),Q={href:"https://zq99299.github.io/note-book/mycat/frontend_connection_interaction.html#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86",target:"_blank",rel:"noopener noreferrer"},E=n("p",null,"所以你的程序具体需要几个 Connection ，这个需要根据你业务量来进行调节，当一个 Connection 上的信道太多时，可能会产生瓶颈，就需要考虑使用多个 Connection 了。",-1),K=n("p",null,"信道在 AMQP 中是一个很重要的概念，大多数操作都在信道这个层面展开的。在前面的代码演示中，也可以看到，很多操作都是在 Channel 对象上完成的。",-1);function M(x,N){const s=c("ExternalLinkIcon");return t(),i("div",null,[_,n("div",f,[B,R,y,v,n("p",null,[a("NIO 中有一个很有名的 "),n("a",Q,[a("Reactor 模式"),o(s)]),a("。")])]),E,K])}const P=e(m,[["render",M],["__file","01.html.vue"]]);export{P as default};
